import {writeFileSync} from "fs";
import {upperFirst} from "lodash";
import assert from "assert";
import {FileEntry, ListOfFiles} from "./types/ListOfFiles";
import {README_NAME} from "./constants";
import {isDir, isFile, notReadme} from "./filters";
import {toLink} from "./toLink";
import removeMdExtensionFromFileName from "./removeMdExtensionFromFileName";

// start with h2
const TOP_LEVEL = 2;

export default function generateReadmesForDirsRecursively(path: string, listOfFiles: ListOfFiles): void {
    const md = convertListOfFilesToMarkdown(path, listOfFiles);
    writeFileSync(`${path}/${README_NAME}`, md);

    const dirEntries = Object.entries(listOfFiles).filter(isDir);
    dirEntries.forEach(
        ([name, content]) => generateReadmesForDirsRecursively(`${path}${name}/`, content)
    );
}

/**
 * @param path
 * @param listOfFiles
 * @param headerLevel header tag depth, e.g. h2, h3
 * headerLevel === TOP_LEVEL means that we are creating list of files in the same dir as Readme,
 * headerLevel > TOP_LEVEL means that we are creating list for subdirectories content
 * */
function convertListOfFilesToMarkdown(
    path: string,
    listOfFiles: ListOfFiles,
    headerLevel = TOP_LEVEL,
): string {
    const header = getLastDirFromPath(path);
    const titleOrDisclaimer = headerLevel === TOP_LEVEL
        ? '<!--This file is autogenerated-->\n'
        : `\n${'#'.repeat(headerLevel)} ${upperFirst(header)}\n`
    ;

    const entries = Object.entries(listOfFiles);
    const fileEntries = entries.filter(isFile).filter(notReadme);

    const makePathRelative = ([fileName, filePath]: FileEntry): FileEntry => {
        // When we are creating list of files on the same level as the generated README.md we don't need any directories
        // in a filepath, when we are 1 level deep we need one, etc.
        const relativePathLengthIncludingTheFile = headerLevel - TOP_LEVEL + 1;

        return [
            fileName,
            filePath
                .split('/')
                .slice(-relativePathLengthIncludingTheFile)
                .join('/')
        ];
    };

    const filesAsMarkdown = fileEntries
        .map(makePathRelative)
        .map(removeMdExtensionFromFileName)
        .map(([fileName, filePath]) => toLink(fileName, filePath))
        .join('\n')
    ;

    const dirEntries = entries.filter(isDir);

    const dirsAsMarkdown = dirEntries.map(([dirName, dirContent]) =>
        convertListOfFilesToMarkdown(`${path}${dirName}/`, dirContent, headerLevel + 1)
    ).join('\n');

    return `${titleOrDisclaimer}${filesAsMarkdown}${dirsAsMarkdown}`;
}

function getLastDirFromPath(path: string): string {
    const pathWithoutTrailingSlash = path.replace(/\/$/, '');
    const result = pathWithoutTrailingSlash.split('/').pop();

    assert(typeof result === 'string');
    return result;
}