---
description: Get started building cross-chain applications
---

# Build with deBridge ðŸ› 

**deBridge** is a generic messaging protocol and decentralized infrastructure that enables any arbitrary cross-chain interactions in a single transaction. Due to the ability to simultaneously send arbitrary assets and data, deBridge acts as a unified framework for all cross-chain needs and is capable of interconnecting any smart contract on any blockchain.&#x20;

### Interact with the deBridge Infrastructure

![Cross-chain smart contract calls through deBridge](<.gitbook/assets/scheme 1.1.png>)

To interact with the deBridge infrastructure is as simple as calling the `send` method of `debridgeGate` smart-contract deployed on all supported blockchains. The method can be called by any arbitrary address â€” either EOA or smart contracts.

```solidity
function send(
    address _tokenAddress,
    uint256 _amount,
    uint256 _chainIdTo,
    bytes memory _receiver,
    bytes memory _permit,
    bool _useAssetFee,
    uint32 _referralCode,
    bytes calldata _autoParams
) external payable;
```

The method accepts the following parameters:

| Parameter Name | Type    | Description                                                                                                                                            |
| -------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| \_tokenAddress | address | Address of the token being sent (`address(0)` for chain base assets like ETH)                                                                          |
| \_amount       | uint256 | Token amount to be transferred                                                                                                                         |
| \_chainIdTo    | uint256 | Id of the receiving chain                                                                                                                              |
| \_receiver     | bytes   | Address of the receiver                                                                                                                                |
| \_permit       | bytes   | In case the token being passed supports [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612), signed permits can be used instead of allowance approvals |
| \_useAssetFee  | bool    | Should also be set to `False`. (Reserved for future use by governance to accept fees in the form of the transferred token)                             |
| \_referralCode | uint32  | Your generated referral code                                                                                                                           |
| \_autoParams   | bytes   | Structure that enables passing arbitrary messages and call data                                                                                        |

{% hint style="info" %}
You can always check examples of cross-chain applications provided below to see how parameters are set for the send method. [Here is](https://github.com/debridge-finance/debridge-contracts-v1/blob/aa8e7ca566807898f57e0f7d01a9533553b11ac9/contracts/examples/Incrementor.sol#L37) an example of the send method for an [**incrementor**](https://github.com/debridge-finance/debridge-contracts-v1/tree/main/examples) smart contract.
{% endhint %}

{% hint style="success" %}
If you integrate with or build applications on top of the deBridge infrastructure, make sure you specify your referral code that can be generated by pressing the WAGMI button at https://app.debridge.finance/. Governance may thank you later for being an early builder.
{% endhint %}

`_autoParams` is a structure that allows passing arbitrary messages and call data to be executed as an external call to the receiver address in the destination chain. This structure also enables setting an executionFee, a reward suggested to any wallet or keeper that will complete the transaction on the target chain. It enables a crypto-economic design where gas fees are paid from the blockchain where the transaction is initiated. The `_autoParams` field has the following structure:

```solidity
struct SubmissionAutoParamsTo {
    uint256 executionFee;
    uint256 flags;
    bytes fallbackAddress;
    bytes data;
}
```

| Parameter Name  | Type    | Description                                                                                                |
| --------------- | ------- | ---------------------------------------------------------------------------------------------------------- |
| executionFee    | uint256 | Suggested reward (in Tokens) paid to anyone who will execute transaction on the destination chain          |
| flags           | uint256 | Flags set specific flows for call data execution                                                           |
| fallbackAddress | bytes   | In case execution of call data fails, all tokens will be transferred to the fallback address               |
| data            | bytes   | Message/Call data to be passed to the receiver on the destination chain during the external call execution |

Flags are a bit mask that allows to achieve specific flow of the transaction execution on the destination chain.

```solidity
library Flags {
    /// @dev Flag to unwrap ETH
    uint256 public constant UNWRAP_ETH = 0;
    /// @dev Flag to revert if external call fails
    uint256 public constant REVERT_IF_EXTERNAL_FAIL = 1;
    /// @dev Flag to call proxy with a sender contract
    uint256 public constant PROXY_WITH_SENDER = 2;
    /// @dev Data is hash in DeBridgeGate send method
    uint256 public constant SEND_HASHED_DATA = 3;
    /// @dev First 24 bytes from data is gas limit for external call
    uint256 public constant SEND_EXTERNAL_CALL_GAS_LIMIT = 4;
}
```

| Flag Name                        | Value | Description                                                                                                                                                                                                                         |
| -------------------------------- | ----- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| UNWRAP\_ETH                      | 0     | Automatically unwrap blockchain base asset                                                                                                                                                                                          |
| REVERT\_IF\_EXTERNAL\_FAIL       | 1     | Revert transaction if external call was not completed                                                                                                                                                                               |
| PROXY\_WITH\_SENDER              | 2     | Set in case receiving smart contract should validate sending chain id and address                                                                                                                                                   |
| SEND\_HASHED\_DATA               | 3     | Pass hash of the call data instead of data itself. Only those who know the original call data will be able to claim the transaction on the target chain. If this flag is set, you should have your own keeper to claim transaction. |
| SEND\_EXTERNAL\_CALL\_GAS\_LIMIT | 4     | Specify minimal gas limit to be passed to external call during the transaction claim                                                                                                                                                |

`PROXY_WITH_SENDER` should be set whenever the receiving smart contract should check whether the message sender is trusted or not. If the flag was set during the claim transaction on the destination chain, the deBridge protocol will automatically store the submissionNativeSender address and submissionChainIdFrom, so that the receiving smart contract can read the properties and validate if the sender is trusted.

![](<.gitbook/assets/Scheme 2.png>)

The receiving smart contract should retrieve the address of callProxy from the debridgeGate smart contract. You can use [onlyControllingAddress](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol#L62) modifier or inherit it from [BridgeAppBase.sol ](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol)to properly implement this validation logic.

### Cross-Chain Smart Contracts Examples

* [Incrementor](https://github.com/debridge-finance/debridge-contracts-v1/tree/main/examples)
* [Referral code](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/InvitationContract.sol) (Cross-chain referral link generator at [deSwap APP](https://app.debridge.finance))
* NFT bridge

