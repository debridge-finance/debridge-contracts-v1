# EVM smart contract interfaces

Interaction with the deBridge infrastructure is as simple as calling the `send` method of `debridgeGate` smart-contract deployed on all supported blockchains. The method can be called by any arbitrary address â€” either EOA or smart contracts.

```solidity
function send(
    address _tokenAddress,
    uint256 _amount,
    uint256 _chainIdTo,
    bytes memory _receiver,
    bytes memory _permit,
    bool _useAssetFee,
    uint32 _referralCode,
    bytes calldata _autoParams
) external payable;
```

The method accepts the following parameters:

<table><thead><tr><th>Parameter Name</th><th width="176.33333333333331">Type</th><th>Description</th></tr></thead><tbody><tr><td>_tokenAddress</td><td>address</td><td>Address of the token being sent (<code>address(0)</code> for chain base assets like ETH)</td></tr><tr><td>_amount</td><td>uint256</td><td>Token amount to be transferred</td></tr><tr><td>_chainIdTo</td><td>uint256</td><td>Id of the receiving chain</td></tr><tr><td>_receiver</td><td>bytes</td><td>Address of the receiver</td></tr><tr><td>_permit</td><td>bytes</td><td>In case the token being passed supports <a href="https://eips.ethereum.org/EIPS/eip-2612">EIP-2612</a>, signed permits can be used instead of allowance approvals</td></tr><tr><td>_useAssetFee</td><td>bool</td><td>Should also be set to <code>False</code>. (Reserved for future use by governance to accept fees in the form of the transferred token) </td></tr><tr><td>_referralCode</td><td>uint32</td><td>Your generated referral code</td></tr><tr><td>_autoParams</td><td>bytes</td><td>Structure that enables passing arbitrary messages and call data</td></tr></tbody></table>

{% hint style="success" %}
If you integrate with or build applications on top of the deBridge infrastructure, make sure you specify your referral code that can be generated by pressing the INVITE FRIENDS button at https://app.debridge.finance/. Governance may thank you later for being an early builder.
{% endhint %}

### AutoParams structure

`_autoParams` is a structure that allows passing arbitrary messages and call data to be executed as an external call to the receiver address on the destination chain. This structure also enables setting an executionFee, a reward suggested to any wallet or keeper that will complete the transaction on the target (destination) chain. It enables a crypto-economic design where gas fees are paid from the blockchain where the transaction is initiated. The `_autoParams` field has the following structure:

```solidity
struct SubmissionAutoParamsTo {
    uint256 executionFee;
    uint256 flags;
    bytes fallbackAddress;
    bytes data;
}
```

<table><thead><tr><th>Parameter Name</th><th width="184.2650802434975">Type</th><th>Description</th></tr></thead><tbody><tr><td>executionFee</td><td>uint256</td><td>Suggested reward (in Tokens) paid to anyone who will execute transaction on the destination chain</td></tr><tr><td>flags</td><td>uint256</td><td>Flags set specific flows for call data execution</td></tr><tr><td>fallbackAddress</td><td>bytes</td><td>In case execution of call data fails, all tokens will be transferred to the fallback address</td></tr><tr><td>data</td><td>bytes</td><td>Message/Call data to be passed to the receiver on the destination chain during the external call execution</td></tr></tbody></table>

### Flags

Flags are a bit mask that allows customizing the transaction execution flow on the destination chain. The bit mask means you can set several flags simultaneously by setting the corresponding bit of `flags` variable to 1

```solidity
library Flags {
    /// @dev Flag to unwrap ETH
    uint256 public constant UNWRAP_ETH = 0;
    /// @dev Flag to revert if external call fails
    uint256 public constant REVERT_IF_EXTERNAL_FAIL = 1;
    /// @dev Flag to call proxy with a sender contract
    uint256 public constant PROXY_WITH_SENDER = 2;
    /// @dev Data is hash in DeBridgeGate send method
    uint256 public constant SEND_HASHED_DATA = 3;
    /// @dev First 24 bytes from data is gas limit for external call
    uint256 public constant SEND_EXTERNAL_CALL_GAS_LIMIT = 4;
    /// @dev Support tx bundling (multi-send) for externall call
    uint256 public constant MULTI_SEND = 5;
}
```

<table><thead><tr><th width="338.9732241107918">Flag Name</th><th width="150">Value</th><th>Description</th></tr></thead><tbody><tr><td>UNWRAP_ETH</td><td>0</td><td>Automatically unwrap blockchain base asset</td></tr><tr><td>REVERT_IF_EXTERNAL_FAIL</td><td>1</td><td>Revert transaction if external call was not completed</td></tr><tr><td>PROXY_WITH_SENDER</td><td>2</td><td>Set in case receiving smart contract should validate sending chain id and address</td></tr><tr><td>SEND_HASHED_DATA</td><td>3</td><td>Pass hash of the call data instead of data itself. Only those who know the original call data will be able to claim the transaction on the target chain. If this flag is set, transaction won't be automatically claimed by external keepers.</td></tr><tr><td>SEND_EXTERNAL_CALL_GAS_LIMIT</td><td>4</td><td>Specify minimal gas limit to be passed to external call during the transaction claim. Gas limit should be passed in the first 4 bytes of the <code>data</code></td></tr><tr><td>MULTI_SEND</td><td>5</td><td>With this flag passed call data will be executed through Gnosis multisend implementation embedded into deBridge callProxy. (Receiver address is not used in this case). Use <a href="https://github.com/gnosis/ethers-multisend">https://github.com/gnosis/ethers-multisend</a> to properly configure data for multisend</td></tr></tbody></table>

`PROXY_WITH_SENDER` should be set whenever the receiving smart contract should check whether the message sender is trusted or not. If the flag was set during the claim transaction on the destination chain, the deBridge protocol will automatically store the submissionNativeSender address and submissionChainIdFrom, so that the receiving smart contract can read the properties and validate if the sender is trusted.

<figure><img src="../../../../.gitbook/assets/Slide 16_9 - 3.png" alt=""><figcaption></figcaption></figure>

The receiving smart contract should retrieve the address of callProxy from the debridgeGate smart contract. You can use [onlyControllingAddress](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol#L62) modifier or inherit it from [BridgeAppBase.sol ](https://github.com/debridge-finance/debridge-contracts-v1/blob/main/contracts/examples/BridgeAppBase.sol)to properly implement this validation logic.

